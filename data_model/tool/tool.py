import abc
import logging
from collections import OrderedDict


class SingletonInstanceMixin(abc.ABC):
    _instance = {}

    def __new__(cls, *args, **kwargs):
        data = kwargs.get("data", None)
        if not data:
            raise ValueError

        if data:
            instance_id = cls._get_instance_id(data)
            instance = cls._instance.get(instance_id, None)
            if instance:
                return instance
            instance = super().__new__(cls)
            cls._instance[instance_id] = instance
            return instance

    @staticmethod
    @abc.abstractmethod
    def _get_instance_id(data):
        raise NotImplementedError

    @property
    def instance_id(self):
        return self._get_instance_id(self.data)

    @classmethod
    def get_instance(cls, instance_id):
        return cls._instance[instance_id]


class NamespacePathMixin(abc.ABC):
    def get_path(self, delimiter: str = "/", filename: bool = False):
        path = delimiter.join(self.namespace)
        if filename:
            return path + ".json"
        return path


class OrderedDictWithCounter:
    def __init__(self):
        self.ordered_dict = OrderedDict()
        self.counter = dict()

    def get_counter_with_data(self):
        return OrderedDict((key, [value, self.counter[key]])
                           for key, value in self.ordered_dict.items())

    def get_counter_with_data_sorted_by_counter(self, reverse: bool = True):
        temp = [[key, [value, self.counter[key]]]
                for key, value in self.ordered_dict.items()]
        temp.sort(key=lambda i: i[1][1], reverse=reverse)
        return OrderedDict((i[0], i[1]) for i in temp)

    def keys(self):
        return self.ordered_dict.keys()

    def values(self):
        return self.ordered_dict.values()

    def items(self):
        return self.ordered_dict.items()

    def __getitem__(self, item):
        return self.ordered_dict[item]

    def __setitem__(self, key, value):
        if key not in self.ordered_dict.keys():
            self.counter[key] = 1
            self.ordered_dict[key] = value
        else:
            self.counter[key] += 1

    def __len__(self):
        return len(self.ordered_dict.keys())

    def counter_adjust(self, instance_id, increment: int):
        self.counter[instance_id] += increment


class PostExecutionManager:
    _post_pool = {"default": []}

    @classmethod
    def get_pool(cls, pool_name: str) -> list:
        return cls._post_pool[pool_name]

    @classmethod
    def add_to_pool(cls, func, *args, pool_name: str = "default"):
        if pool_name not in cls._post_pool.keys():
            cls._post_pool[pool_name] = []
        cls._post_pool[pool_name].append((func, args))

    @classmethod
    def execute_pool(cls, pool_name: str):
        try:
            for i in cls._post_pool[pool_name]:
                i[0](*i[1])
        except KeyError:
            logging.warning(f"No such pool: {pool_name}")

    @classmethod
    def execute_all(cls):
        for i in cls._post_pool.keys():
            cls.execute_pool(i)


class ObjectAccessProxier:
    """提供一种代理方式来访问对象"""

    def __init__(self, obj):
        self._object = obj
        self.set_default_policy()

    def set_default_policy(self):
        self.allow_del = False
        self.allow_set = False
        self.allow_get = True

        # 自定义返回内容
        self.custom_get = {}

    def __getattribute__(self, item):
        if not self.allow_get:
            raise PermissionError

        if item in self.custom_get.keys():
            return self.custom_get[item]
        return getattr(self._object, item)

    def __setattr__(self, key, value):
        if not self.allow_set:
            raise PermissionError

        setattr(self._object, key, value)

    def __delattr__(self, item):
        if not self.allow_del:
            raise PermissionError

        delattr(self._object, item)

def seconds_to_minutes(seconds: int):
    return seconds // 60, seconds % 60


def counter_dict_sorter(d: OrderedDict, key_name: list, reverse: bool = False, ignore_key_errors: bool = True):
    # sort the dict generated by `OrderedDictWithCounter.get_counter_with_data_sorted_by_counter`
    # tip: it also exports to json automatically, so just call it like
    #   counter_dict_sorter(OrderedDictWithCounter.get_counter_with_data_sorted_by_counter())

    # separate different items with different counts
    counter_and_item = {}
    for key, value in d.items():
        counter = value[1]
        if counter not in counter_and_item.keys():
            counter_and_item[counter] = []

        # export to json (to_json_basic)
        json_export = value[0].to_json_basic()

        counter_and_item[counter].append([key, [json_export, counter]])

    # define a function to return all the values of the keys wanted in sorting
    def get_all_keys(item):
        actual_dict = item[1][0]
        values = []

        for i in key_name:
            try:
                if isinstance(i, str):
                    values.append(actual_dict[i])
                elif isinstance(i, list):
                    _curr = actual_dict
                    for j in i:
                        _curr = _curr[j]
                    values.append(_curr)
            except KeyError:
                if not ignore_key_errors:
                    raise

        values = tuple(values)
        return values

    # sort the dict
    for item_list in counter_and_item.values():
        item_list.sort(key=get_all_keys, reverse=reverse)

    # pack back
    new_d = OrderedDict()
    for item_list in counter_and_item.values():
        for item in item_list:
            new_d[item[0]] = item[1]

    return new_d


def uuid_crafter(string: str):
    if len(string) != 32:
        raise ValueError("Should provide a 32-character-long string!")

    a, b, c, d, e = slice(0, 8), slice(8, 12), slice(12, 16), slice(16, 20), slice(20, 32)
    all_slices = [a, b, c, d, e]
    return "-".join([string[i] for i in all_slices])
